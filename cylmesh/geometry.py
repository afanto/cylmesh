"""
Geometry generation module for Gmsh mesh files.
"""

from .utils import ValidationError, validate_matching_lengths


class GeometryGenerator:
    """Generates Gmsh geometry scripts for cylindrical multilayer structures."""
    
    def __init__(self, ml, radius, layer_thicknesses, subdivisions=None, layer_names=None):
        """
        Initialize the geometry generator.
        
        Args:
            ml: Mesh length (characteristic element size)
            radius: Cylinder radius
            layer_thicknesses: List of layer thicknesses
            subdivisions: List of vertical subdivisions per layer (optional)
            layer_names: List of layer names (optional)
        """
        self.ml = ml
        self.radius = radius
        self.layer_thicknesses = layer_thicknesses
        
        # Set default subdivisions if not provided
        if subdivisions is None:
            self.subdivisions = [1] * len(layer_thicknesses)
        else:
            validate_matching_lengths(subdivisions, layer_thicknesses, "subdivisions", "layers")
            self.subdivisions = subdivisions
            
        # Validate layer names if provided
        if layer_names:
            validate_matching_lengths(layer_names, layer_thicknesses, "layer names", "layers")
        self.layer_names = layer_names
    
    def generate_geo_script(self):
        """Generate the complete Gmsh geometry script."""
        geo_parts = []
        
        geo_parts.append(self._generate_header())
        geo_parts.append(self._generate_variables())
        geo_parts.append(self._generate_mesh_settings())
        geo_parts.append(self._generate_geometry())
        geo_parts.append(self._generate_extrusions())
        geo_parts.append(self._generate_coherence())
        geo_parts.append(self._generate_physical_surfaces())
        geo_parts.append(self._generate_physical_volumes())
        
        return "\n".join(geo_parts)
    
    def _generate_header(self):
        """Generate file header with metadata."""
        return """// Generated by CylMesh
// Author: Afan Terko, July 2025
// All units in nm"""
    
    def _generate_variables(self):
        """Generate variable definitions."""
        parts = []
        parts.append(f"ml = {self.ml};        // mesh length")
        parts.append(f"radius = {self.radius}; // radius of cylinder, nm")
        parts.append("")
        parts.append("// Layer thicknesses")
        
        for i, thickness in enumerate(self.layer_thicknesses, 1):
            parts.append(f"t{i} = {thickness};")
        
        parts.append("")
        parts.append("// Number of discretisation layers (vertical subdivisions)")
        for i, nz in enumerate(self.subdivisions, 1):
            parts.append(f"nz{i} = {nz};")
        
        return "\n".join(parts)
    
    def _generate_mesh_settings(self):
        """Generate mesh algorithm settings."""
        return """
// Mesh settings
Mesh.Algorithm = 6;           // Frontal-Delaunay for 2D
Mesh.Algorithm3D = 1;         // Delaunay for 3D
Mesh.ElementOrder = 1;        // Linear elements
Mesh.Optimize = 1;            // Enable optimization
Mesh.OptimizeNetgen = 1;      // Netgen optimization"""
    
    def _generate_geometry(self):
        """Generate basic geometry (points, circles, surfaces)."""
        return """
// Define perimeter points for initial surface
Point(1) = {0, 0, 0, ml};
Point(2) = {radius, 0, 0, ml};
Point(3) = {0, radius, 0, ml};
Point(4) = {-radius, 0, 0, ml};
Point(5) = {0, -radius, 0, ml};

// Define arcs to form circular boundary
Circle(1) = {2,1,3};
Circle(2) = {3,1,4};
Circle(3) = {4,1,5};
Circle(4) = {5,1,2};

// Create line loop from arcs
Line Loop(5) = {1,2,3,4};

// Create 2D surface from line loop
Surface(1) = {5};

// Extrude volumes for each layer"""
    
    def _generate_extrusions(self):
        """Generate extrusion commands for each layer."""
        parts = []
        for i in range(len(self.layer_thicknesses)):
            if i == 0:
                parts.append(f"s{i}[] = Extrude{{0, 0, t{i+1}}} {{ Surface{{1}}; Layers{{nz{i+1}}}; }};")
            else:
                parts.append(f"s{i}[] = Extrude{{0, 0, t{i+1}}} {{ Surface{{s{i-1}[0]}}; Layers{{nz{i+1}}}; }};")
        return "\n".join(parts)
    
    def _generate_coherence(self):
        """Generate coherence command."""
        return "\n// Merge identical geometry (important to ensure connectivity!)\nCoherence;"
    
    def _generate_physical_surfaces(self):
        """Generate physical surface definitions."""
        parts = []
        parts.append("\n// Physical Surfaces")
        
        # Bottom surface - use the name of the first layer
        if self.layer_names and len(self.layer_names) > 0:
            bottom_surface_name = f"{self.layer_names[0]}_bottom"
            bottom_comment = f"// bottom of {self.layer_names[0]}"
        else:
            bottom_surface_name = "1_bottom"
            bottom_comment = "// bottom of layer 1"
        parts.append(f'Physical Surface("{bottom_surface_name}") = {{1}};       {bottom_comment}')
        
        for i in range(len(self.layer_thicknesses)):
            if self.layer_names and i < len(self.layer_names):
                surface_name = f"{self.layer_names[i]}_top"
                comment = f"// top of {self.layer_names[i]}"
            else:
                surface_name = f"{i+1}_top"
                comment = f"// top of layer {i+1}"
            parts.append(f'Physical Surface("{surface_name}") = {{s{i}[0]}};   {comment}')
        
        return "\n".join(parts)
    
    def _generate_physical_volumes(self):
        """Generate physical volume definitions."""
        parts = []
        parts.append("\n// Physical Volumes")
        
        for i in range(len(self.layer_thicknesses)):
            if self.layer_names and i < len(self.layer_names):
                volume_name = self.layer_names[i]
                comment = f"  // {self.layer_names[i]}"
            else:
                volume_name = str(i+1)
                comment = f"  // Layer {i+1}"
            parts.append(f'Physical Volume("{volume_name}") = {{s{i}[1]}};{comment}')
        
        return "\n".join(parts)
